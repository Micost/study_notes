# 深度理解TCP连接建立过程

## 深度理解TCP连接建立过程

### 相关实例问题

又来了, 都是一些和TCP相关的

### 深入理解listen

开始接收之前都需要执行一下Listen

#### listen 系统的调用

调用方式, sock->ops-> listen

#### 协议栈Listen

服务端的全连接队列长度是执行listen函数时传入的backlog和net.core.somaxconn 之间较小的那个值.

#### 接收队列定义

因为服务端需要在第三次握手时快速地查找出来第一次握手时留存的request\_sock对象, 所以其实是用了一个哈希表来管理, 就是struct request\_sock \*syn\_table\[0].

#### 接收队列申请和初始化

先计算半连接队列的长度, 计算出来实际大小之后, 开始申请内存.

#### 半连接队列长度计算

半连接队列长度是min(backlog, somaxconn, tcp\_max\_syn\_backlog) +1 再上取整到2的N次幂, 最小不能小于16. 本质上, 内存记录的是N次幂, 如果队列长度为16, 则记录长度为4.

#### listen 过程小结

所谓服务端socket程度流程:先bind, 再listen然后才能accept. Listen 的主要工作是申请和初始化接收队列, 包括全连接队列和半连接队列. 全连接队使用链表, 半连接使用哈希表.

还有一个地方是关于内核如何获取到队列长度的.P148自己查吧, 就不写了. 主要是看不到有什么用.

### 深入理解Connect

客户端发起连接的时候 , 创建一个socket , 然后瞄准服务端调用connect. 所以这部分主要是说这个connect是怎么实现的.

#### Connect 调用链的展开

根据用户传入的FD来查询对应的socket内核对象, 对于AF\_INET类型的对象来说, socket->ops->connect指针指向的是inet\_stream\_connect函数. 主要做的是两个事情, 一个是根据socket状态判断进入不同的逻辑 , 另一个是选择端口后发送, 然后改状态.

#### 选择可用的端口

计算出一个随机数开始从这个数遍历所有可用的端口范围的端口, 直到找到可用的端口. 系统会维护一个所有使用的端口的哈希表, 如果没在这个表中找到, 说明端口没有被使用.

#### 端口被使用过怎么办

被使用后的端口, 还可以再次判断是否可以使用.

```
客户端的IP和端口+服务端IP和端口, 是一个四元组, 只要有一个不一样, 就算是另一个连接.
```

#### 发起syn请求

申请一个skb, 设置为SYN包, 发出去看看会不会超时.超时会重发. Linux 3.1 超时为1秒, 旧版本是3秒.

#### connect 小结

要注意的是, 如果端口太少, connect系统调用的CPU开销上涨

### 完整TCP连接建立过程

怎么建立的呢? 三次握手(SYN, SYN ACK, ACK), 但是这个货想多说点.

#### 客户端connect

客户端发送之后会把socket 状态置为TCP\_SYN\_SENT

#### 服务端响应SYN

响应ack的主要工作是判断队列是否满了. 满了就会丢弃请求

#### 客户端响应SYNACK

判断状态,处理,将状态改为ESTABLISHED.清理重传计时器,发出ACK开启保活计时器

#### 服务端响应ACK

把当前半连接对象删除, 创建了新的SOCKET后加入全连接队列, 把新连接状态设置为ESTABLISHED.

#### 服务端accept

从己经建好的全连接队列中取出一个给用户

#### 连接建立总结

P168这个图不错

### 异常TCP连接建立情况

主要是耗时超过了一个RTT(round trip time), 会出问题.

#### connect系统调用耗时失控

端口不足可能会导致调用耗时.

#### 第一次握手丢包

半连接队列满

```
半连接队列满 的时候 会直接丢包
```

全加接队列满

```
同样丢包
```

客户端发起重试, 会阻塞进程

#### 第三次握手丢包

第三次握手时, 如果服务器队列满了, 来自客户端的ack握手包又会被直接丢弃 服务端会再次发起synack, 然后客户端会再次发ack, 如果全连接队列一直都是满的, 服务端重试5次后就放弃了. 在成功前发送的数据都会被服务端无视.

#### 握手异常总结

上面说的那个几个问题, 然后就是怎么解决

1. 找开ysncookie
2. 加大连接队列长度
3. 尽快调用accept
4. 尽早拒绝
5. 尽量减少TCP连接的次数

### 如何查看是否有连接队列溢出发生

#### 全连接队列的判断

会更新到listenoverflows 这个MIB(management information base)

```
netstat -s |grep overflowed
```

#### 半连接队列的判断

更新LINUX\_MIB\_LISTENDROPS这个MIB, 只要保证tcp\_syncookies这个内核参数是1就能保证不会因为半连接列满而发生的丢包

不只有半连接队列发生溢出时会增加, 所以同时查看当前listen端口上的syn\_recv的数量

```
netstat -s |grep SYN_RECV
```

如果这个值达到了算出来的半队列的长度, 那就是满了

#### 小结

不知道为什么要小结一下, 反正就是上面说的那种.

### 本章总结

回答一下之前的几个问题

1.  为什么要先listen一下

    因为要创建半连接和全连接队列
2.  长度怎么确定

    太长了, 不说了
3.  Cannot assign requested address

    这个错误就是没有找到端口, 加大端口范围
4.  一个客户端口可以同时用在两条连接上吗

    可以
5.  半/全连接满了会怎么样

    丢包 -> 超时
6.  新连接的socket内核对象是什么时候建立的

    核心部分是struct sock, 在第三次握手之后建立的
7.  建立一条TCP连接需要多长时间

    正常是一个RTT, 不正常可能最少1秒
8.  服务器在北京, 给纽约的用户访问可以吗

    想啥呢
9.  服务器负载正常, 但是CPU被打满了, 什么原因

    请求太频繁, connect消耗掉大量的CPU.
