# 内核是如何发送网络包的

## 内核是如何发送网络包的

### 又是相关实际问题

这回的问题主要是和网络发送有关的问题.

### 网络包发送过程总览

用户数据被拷贝到内核态, 然后经过协议栈处理后进八ringbuffer, 随后网卡驱动真正将数据发送了出去, 当发送完成的时候, 是通过硬中断来通知CPU,然后清理ringbuffer.\
因为传输完成之后清理的硬中断会触发NET\_RX\_SOFIRQ, 是RX而不是TX, 所以看到中断的时候会发现RX数据要比TX大很多.

### 网卡启动准备

主要就是初始化和分配ringbuffer, 与接收一样, ringBuffer不是一个队列, 而是两个队列. 一个是内核使用, 另一个是网卡硬件使用的. 两个数组相同位置指针指向同一个skb, 内核写数据, 网卡发送.

### 数据从用户进程到网卡的详细过程

#### send系统调用实现

1. 在内核中把真正的socket找出来, 在这个对象里记录着各中协议栈的函数地址
2. 构造一个struct msghdr对象, 把用户传入的数据, 比如bugger地址, 数据长度什么都传进去.

然后交给下一层.

#### 传输层处理

传输层拷贝

```
把skb加入到队列, 不一定会发送(取决于是否满足条件).
```

传输层发送

```
发送前是先克隆一个新的skb, 因为有可能会重传.  
修改tcp头: 实际上skb中本来就有所有协议的头, 改一改指针就可以定义到合适的头.
```

接下来就是交给网络层

#### 网络层发送处理

1. 查找设置路由项
2. 设置 IP 头
3. netfilter 过滤
4. 大于MTU 要对skb分片 (尽量不要大于MTU)

然后进入下一层

#### 邻居子系统

本身上位于网格层和数据链路层中间的一个系统, 作用是为网络层提供一个下层的封装, 让网络层不需要关心下层的地址信息.\
所做的事情, 可以理解为查找或创建邻居项, 然后封装MAC头.再给更下层

#### 网络设备子系统

1. 选择发送队列
2. 获取排队规则
3. SKB入队
4. 循环遍历发送队列或者触发
5.  取出SKB发送

    qdisc queueing discipline 队列规则

发送的时候不一定需要触发软中断进行发送, 所以发送不一定触发这NET\_TX. 只有有quota用尽或者其他进程需要时才会通过软中断发送.\
通过驱动程序发送.

#### 软中断调度

上面条件中, 触发软中断的情况. 最后也是通过驱动程序发送.\
发送数据的消耗的CPU就显示在SI这里, 不会消耗用户进程的系统时间.

#### igb网卡驱动发送

从网卡的发送队列的ringbuffer取下一个元素, 最后放到DMA区域.\
到了DMA就是真的发送了

### RingBuffer内存回收

软中断清理了SKB , 解除了DMA映射. 就基本差不多了. 实际上是收到ACK之后才会把skb真正删除.

### 本意总结

又开始回答问题了.

发送数据的消耗CPU 是si还是sy

```
大部分都是sy, 只有少量需要软中断的地方才是si
```

为什么NET\_RX要比NET\_TX大的多

```
1. 因为清理Ringbuffer本身就是NET_RX的软中断
2. 不是每个发送都需要软中断. 
```

发送数据都涉及哪些内存的拷贝操作

```
1. 用户数据到SKB
2. skb 在网络层的克隆
3. 大于MTU时 把skb分成小的. 
```

什么是零拷贝

```
以sendfile 举例, 不需要从内核态拷贝到用户态.
```

为什么KAFKA这么优秀

```
因为用了sendfile
```
